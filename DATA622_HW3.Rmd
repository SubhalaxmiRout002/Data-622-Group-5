---
title: "DATA622_HW3"
author: "Group 5"
date: "`r Sys.Date()`" # Due 4/9/2021
output: 
 html_document:
    toc: true
    toc_float: true
    code_folding: hide
    theme: flatly
    highlight: tango
---

## Authorship

**Group 5:** 

* Don (Geeth) Padmaperuma,
* Subhalaxmi Rout, 
* Isabel Ramesar, and
* Magnus Skonberg

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r library, comment=FALSE, warning=FALSE, message=FALSE }
library(tidyverse)
library(caret)
library(palmerpenguins)
library(e1071) 
library(caTools)
library(ggplot2)
library(GGally)
library(ggplot2) 
library(MASS) 
library(mvtnorm)
library(class)
library(dplyr)
library(rpart)
library(rpart.plot)
library(party)
library(randomForest)
library(gbm)
library(mice)
library(plyr)
library(gridExtra)
```

# Background

The purpose of this assignment was to explore classification via K-nearest neighbors, Decision Trees, Random Forests, and Gradient Boosting.

## Classification

Classification is a supervised machine learning technique whose main purpose is to identify the category/class of provided input data.  The model that is generated is trained using labeled data (hence the label "supervised") and then use the trained model is used to predict our discrete output. 

## Our Approach

First, we're going to predict `species` of penguin using the KNN algorithm.

Then we're going to compare and contrast `loan approval status` predictions for Decision Trees, Random Forests and Gradient Boosting.

................................................................................


# Palmer Penguins Data

Being that we've worked with the penguins dataset twice before, we perform *light EDA* to re-familiarize ourselves with the data prior to applying the KNN algorithm to it.

We load in the data, pre-process it, verify the first 6 observations, and utilize the built-in glimpse() function to gain insight into the dimensions, variable characteristics, and value range:

```{r}
#Load and tidy data 
penguin_measurements <- penguins %>% drop_na() %>%
    dplyr::select(species, bill_length_mm, bill_depth_mm,
                  flipper_length_mm, body_mass_g)

head(penguin_measurements%>% as.data.frame())
glimpse(penguin_measurements)
```

Once we've dropped NA values and selected pertinent variables, we end up with a 333 observation x 5 variable dataframe with:

* `species`, a categorical variable of type factor, as our dependent variable and
* `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`, and `body_mass_g`, all quantitative variables of type dbl or int, as our independent variables.


# 1. K-Nearest Neighbors (KNN)

[insert background on KNN]

The KNN algorithm hinges on the idea that similar data will be near one another. When applying KNN, the distance between data points are used to classify data. Those nearer one another are "batched" together. The amount of batches we see and the distance between points is determined by the k value we select:

* Smaller k --> fewer batches and larger distance between "like" points.
* Larger k --> more batches and smaller distance between "like" points. 

Due to the simplicity of calculations involved and ease of interpretability of the result, KNN is a popular classifier. For our purposes, we're going to apply the K-nearest neighbor algorithm to the Palmer penguins dataset to predict the `species` variable.

We perform an 80-20 split, center and scale our independent variables via built-in scale() function, and fit the KNN model to our training dataset:

```{r}
# Splitting data into train and test data 
set.seed(123) 
training.individuals <- penguin_measurements$species %>%
    createDataPartition(p = 0.8, list = FALSE) 

train_cl <- penguin_measurements[training.individuals, ] 
test_cl <- penguin_measurements[-training.individuals, ] 

# Feature Scaling 
train_scale <- scale(train_cl[, 2:5]) 
test_scale <- scale(test_cl[, 2:5]) 

# Fitting KNN Model to training dataset 
classifier_knn <- knn(train = train_scale, 
					test = test_scale, 
					cl = train_cl$species, 
					k = 1) 

#classifier_knn #verify output
```

Performing an 80-20 split allocates 80% of our data for training the model and 20% of our data for testing it. Whereas applying the scale() function centers and scales our independent variables to reduce bias and improve predictive accuracy. *Although, we start with k=1 (neighbors) for our KNN model fit here. We'll vary this value later to interpret its impact on predictive accuracy.*

Once our model has been fit, we assess its accuracy visualizing with a confusion matrix and then calculating the corresponding accuracy based on these values:

```{r}
# Confusion Matrix 
cm <- table(test_cl$species, classifier_knn) 
cm 

# Model Evaluation - Choosing K Calculate out of Sample error 
misClassError <- mean(classifier_knn != test_cl$species) 
print(paste('Accuracy =', 1-misClassError)) 
```

In the confusion matrix above, rows represent actual values while columns represent predicted values. With this in mind, we see that our test set results are:

* True Positive Result (TPR): 61 / 65 = 93.8%
* False Positive Result (FPR): 4 / 65 = 6.2%

Although our KNN classifier mis-predicted an Adelie as a Chinstrap and 3 Chinstraps as Adelies, it predicted Gentoo with 100% accuracy and produced a relatively favorable **93.8% accuracy**.

Let's explore the impact of increasing our k value to 3:

```{r}
# K = 3 
classifier_knn <- knn(train = train_scale, 
					test = test_scale, 
					cl = train_cl$species, 
					k = 3) 
misClassError <- mean(classifier_knn != test_cl$species) 
print(paste('Accuracy (k=3):', 1-misClassError)) 


```

We don't visualize the output with a confusion matrix and instead calculate the sample error and just subtract this value from 1 to produce a predictive **accuracy of 95.4%**. A 1.6% improvement over our KNN classifier with k=1.

We, once again, explore the impact of increasing our k value. This time we increase it to 15:

```{r}
# K = 15 
classifier_knn <- knn(train = train_scale, 
					test = test_scale, 
					cl = train_cl$species, 
					k = 15) 
misClassError <- mean(classifier_knn != test_cl$species) 
print(paste('Accuracy (k=15):', 1-misClassError)) 
```

With k=15 **our predictive accuracy climbs to 96.9%.** A 1.5% improvement over our KNN classifier with k=3. In our case, each increase in k value improved our predictive accuracy. This is not always the case though ... 

When choosing k values, smaller values are generally less computationally expensive *yet* they're also noisier and less accurate. Larger values, on the other hand, can result in smoother decision boundaries and a lower variance *yet* they increase the bias and processing demands. 

Thus, more often than not we seek the "sweet spot". A k value that's not too large and not too small. Our choice in value is thus impacted by the number of observations, as well as the characteristics of the data we're classifying.

................................................................................


# Loan Approval Data

Being that we haven't worked with the loan approval dataset before, our exploratory data analysis (EDA) will be more in-depth. The depth will allow for greater understanding of the data at hand prior to applying a Decision Tree, Random Forest, and Gradient Boosting model to it.

We load in the data, replace empty strings with NAs, and observe the first 6 observations of our dataset:

```{r}
#Load in data
loan <- read.csv("https://raw.githubusercontent.com/SubhalaxmiRout002/Data-622-Group-5/main/Loan_approval.csv", stringsAsFactors = TRUE)

loan[loan==""] <- NA #replace empty strings with NAs
#head(loan) #verify 1st 6 observations
```

The head() function provides some context regarding the format of our data. R's built-in glimpse() and summary() functions provide further insight:

```{r}
#Light EDA
glimpse(loan)
summary(loan)
```


We're dealing with a 614 observation x 13 variable dataframe with:

* `Loan_Status`, a categorical, character-based variable, as our dependent variable,
* `ApplicantIncome`, `CoApplicantIncome`,`LoanAmount`, `Loan_Amount_Term`, and `Credit_History`, all quantitative variables of type dbl or int, as independent variables, and
* `Loan_ID`, `LoanGender`, `Married`, `Dependents`, `Education`, `Self_Employed`, `Property_Area`, and `Loan_Status`, all categorical, character-based variables, as independent variables.

From the above output, we also get an idea of proportions for our variables of type factor (ie.`Gender`: 489 male, 112 female applicants) which we can explore in greater depth later.

Of the above variables, we can see that `Loan_ID` does not appear to provide much insight. We'll drop this variable, explore a clearer visualization of NA counts and then deal with our NA values: 

```{r}
loan <- subset(loan, select = -c(1) ) #drop Loan_ID from consideration

colSums(is.na(loan)) #visualize NA counts
```

7 / 12 variables have NA values and 3 of these variables have more than 20 NA values (a relatively significant margin).

We *can* drop these values but dropping values means losing valuable observations and thus we elect to impute instead. From the mice library, we impute using the **pmm** method (predictive mean matching):

```{r}
#relabel Dependents "3+" value as "3" so that we can impute values
loan$Dependents <- revalue(loan$Dependents, c("3+"="3"))

#apply predictive mean matching to loan data
loan <- mice(loan, m = 1, method = "pmm", seed = 500)
loan <- mice::complete(loan, 1)
```

We re-assign the "3+" value of the `Dependents` variable to provide consistent leveling and enable **pmm** and then we actually apply **pmm**.

Predictive mean matching calculates the predicted value for our target variable, and, for missing values, forms a small set of “candidate donors” from the complete cases that are closest to the predicted value for our missing entry. Donors are then randomly chosen from candidates and imputed where values were once missing. *To apply pmm we assume that the distribution is the same for missing cells as it is for observed data, and thus, the approach may be more limited when the % of missing values is higher.*

Once we've imputed missing values into our loan dataset and returned the data in proper form, we verify whether our operation was successful:

```{r}
#verify absence of NA values in the dataset
colSums(is.na(loan))
```

Imputation was a success and thus our data pre-processing has been completed. We can proceed with our exploratory data analysis (EDA).

To identify features that carry promise vs. those that may not, we consider a correlation matrix for our numeric variables: 

```{r, messages=FALSE}
#Correlation matrix for numeric variables
library(corrplot)

#Loan Approved correlation
loan_corr_y <- loan %>%
    filter(Loan_Status == "Y") %>%
    select_if(is.numeric) %>%
    cor()

corrplot(loan_corr_y, title="Loan Approved")

#Loan Rejected correlation
loan_corr_n <- loan %>%
    filter(Loan_Status == "N") %>%
    select_if(is.numeric) %>%
    cor()

corrplot(loan_corr_n, title="Loan Rejected")
```

When we consider loan approval and rejection, `LoanAmount` and `ApplicantIncome` have a relatively strong correlation. For loan rejection, `LoanAmount` also appears to have moderate correlation with `CoapplicantIncome`. Remaining features do not have strong correlation and thus we'll only note the aforementioned relationships for consideration for *possible* feature removal later. 

We move on to explore histograms for our numeric variables:

```{r eda, eval = T}
#Histograms for all variables
loan %>%
    keep(is.numeric) %>%
    subset(select = -c(4,5)) %>% #drop CreditHistory, Loan_Amount_Term
    gather() %>% 
    ggplot(aes(value)) +
        facet_wrap(~ key, scales = "free", ncol=1) +
        geom_histogram(bins=90,color="darkblue", fill="lightblue")

```
From the above figures we observe that:

* `ApplicantIncome` and `LoanAmount` appear to be right skewed normal with a number of noteworthy outliers, and
* `CoapplicantIncome` has a peak at 0 joined with an otherwise right skewed normal distribution.

All three numeric variables would require normalization for modeling consideration.

Next, we explore our categorical variables:

```{r, message=FALSE}
#convert CreditHistory to type factor
loan$Credit_History <- factor(loan$Credit_History)
#levels(loan$Credit_History) #verify

#MS: if there's a way to facet wrap this / automate, would be preferred:

#Histograms for all categorical variables
##Gender
p1 <- loan %>% 
    dplyr::select(1,12) %>% #dplyr::select(1:5,11:12)
    group_by(,Loan_Status) %>%
    #gather() %>%
    count() %>%
    
    ggplot(aes(x=Gender, y=freq, fill=Loan_Status)) + 
        #facet_wrap(~ key) +
        geom_bar(stat='identity', position="stack")

##Married
p2 <- loan %>% dplyr::select(2,12) %>% group_by(,Loan_Status) %>% count() %>%
    ggplot(aes(x=Married, y=freq, fill=Loan_Status)) + 
        geom_bar(stat='identity', position="stack")

##Dependents
p3 <- loan %>% dplyr::select(3,12) %>% group_by(,Loan_Status) %>% count() %>%
    ggplot(aes(x=Dependents, y=freq, fill=Loan_Status)) + 
        geom_bar(stat='identity', position="stack")

##Education
p4 <- loan %>% dplyr::select(4,12) %>% group_by(,Loan_Status) %>% count() %>%
    ggplot(aes(x=Education, y=freq, fill=Loan_Status)) + 
        geom_bar(stat='identity', position="stack")

##Self_Employed
p5 <- loan %>% dplyr::select(5,12) %>% group_by(,Loan_Status) %>% count() %>%
    ggplot(aes(x=Self_Employed, y=freq, fill=Loan_Status)) + 
        geom_bar(stat='identity', position="stack")

##Property_Area
p6 <- loan %>% dplyr::select(11,12) %>% group_by(,Loan_Status) %>% count() %>%
    ggplot(aes(x=Property_Area, y=freq, fill=Loan_Status)) + 
        geom_bar(stat='identity', position="stack")

grid.arrange(p1, p2, p3, p4, p5, p6, nrow = 3, ncol = 2)

```

From the above figures we can extend the following observations:

* **males outnumber females** and **non self employed outnumber self employed** on a 5:1 basis, **married outnumber non married** on a 2:1 basis, **those without dependents make up a majority**, those that have **graduated make up a majority**, and those with **properties in semiurban area make up a slight majority** of loan applications for the data under our consideration,
* with regard to loan approval, the only clearer takeaway is that it appears that **those in semiurban areas are approved at a greater rate than those in rural and urban areas**.

While the visualization of our six categorical variables distributions with regard to our dependent variable is enlightening, it doesn't appear to provide clear indication regarding one vs. another's predictive capabilities.

Prior to predicting loan approval using Decision Trees, Random Forests, and Gradient Boosting, we're to normalize the numerical variables noted earlier.

Being that we're dealing with positively skewed data at a rather extreme magnitude, well utilize the log transform:

###MS: 3.24.21 LEFT OFF HERE

```{r}
#normalization: account for outliers with log transform

```

................................................................................


# 2. Decision Trees

2. Please use the attached dataset on loan approval status to predict loan approval using Decision Trees. Please be sure to conduct a thorough exploratory analysis to start the task and walk us through your reasoning behind all the steps you are taking. (40 points)

```{r}
#Split data into training and testing sets
set.seed(123)
sample_data = sample.split(loan, SplitRatio = 0.75)
train_data <- subset(loan, sample_data == TRUE)
test_data <- subset(loan, sample_data == FALSE)
```

```{r}
#Class Method
prop.table(table(loan$Loan_Status))
fit <- rpart(Loan_Status~., data = loan, method = 'class')
rpart.plot(fit, extra = 106)
```

```{r}
fit <- rpart(Loan_Status~., data = loan, method = 'class')
predict_unseen <-predict(fit, loan, type ='class')
table_mat <-table(loan$Loan_Status, predict_unseen)
table_mat
accuracy_Test <-sum(diag(table_mat))/sum(table_mat)
print(paste('Accuracy for test', accuracy_Test))
```


## Random Forests
3. Using the same dataset on Loan Approval Status, please use Random Forests to predict on loan approval status. Again, please be sure to walk us through the steps you took to get to your final model. (50 points)
```{r}
#Create the forest
#output.forest <-randomForest(Loan_Status~ Gender + Married + Dependents + ApplicantIncome + LoanAmount + Loan_Amount_Term + Credit_History + Property_Area, data = loan)

#View the forest results
#print(output.forest)

#Importance of each predictor
#print(importance(output.forest, type=2))
```
From the random forest shown above we can conclude that Credit_History, Applicant_Income and Loan_Amount are the most important factors when deciding if someone will be approved for a loan or not. The model has a 17.96% error which means we can predict with 82.04% accuracy.

```{r randomforestplot}
#plot(output.forest)
#varImpPlot(output.forest)
```

```{r randomforestprediction}
#new <- data.frame(Gender='Male', Married='Yes', Dependents=0, ApplicantIncome=2000, LoanAmount=300, Loan_Amount_Term=360, Credit_History=1, Property_Area='Urban')
#predict(output.forest, newdata =new)
```



## Gradient Boosting
4. Using the Loan Approval Status data, please use Gradient Boosting to predict on the loan approval status. Please use whatever boosting approach you deem appropriate; but please be sure to walk us through your steps. (50 points)

```{r}
#Separating training and test data
#train=sample(1:261, size = 261)
#loan.boost=gbm(Loan_Status ~ . ,data = loan[train,],distribution = "gaussian",n.trees = 10000, shrinkage = 0.01, interaction.depth = 4)
#loan.boost

#Summary gives a table of Variable Importance and a plot of Variable Importance
#summary(loan.boost)
```

```{r gradientboostplot}
#plot(loan.boost, i="LoanAmount")
#plot(loan.boost, i="ApplicantIncome")
```

```{r}
#cor(loan$LoanAmount, loan$Credit_History)
#cor(loan$ApplicantIncome, loan$Credit_History)
```

## Model Comparison (Decision Trees vs. Random Forests vs. Gradient Boosting)
5. Model performance: please compare the models you settled on for problem # 2 – 4. Comment on their relative performance. Which one would you prefer the most? Why? (20 points)

# References
https://www.geeksforgeeks.org/k-nn-classifier-in-r-programming/
https://guru99.com/r-decision-trees.html/
https://www.geeksforgeeks.org/decision-tree-for-regression-in-r-programming/
https://data-flair.training/blogs/r-decision-trees/
https://tutorialspoint.com/r/r_random_forest.htm/
https://statology.org/random-forest-in-r/
https://datascienceplus.com/gradient-boosting-in-r/
https://appsilon.com/r-xgboost/

